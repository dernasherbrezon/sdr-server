#include <stdlib.h>
#include <unity.h>
#include "utils.h"
#include "../src/xlating.h"
#include "../src/lpf.h"

xlating *filter = NULL;
uint8_t *input = NULL;

void setup_filter(size_t input_offset, size_t input_len, size_t max_input) {
  uint32_t sampling_freq = 48000;
  uint32_t target_freq = 9600;
  float *taps = NULL;
  size_t len;
  int code = create_low_pass_filter(1.0f, sampling_freq, target_freq / 2, 2000, &taps, &len);
  TEST_ASSERT_EQUAL_INT(code, 0);
  code = create_frequency_xlating_filter((int) (sampling_freq / target_freq), taps, len, -12000, sampling_freq, max_input, &filter);
  TEST_ASSERT_EQUAL_INT(code, 0);
  setup_input_data(&input, input_offset, input_len);
}

void test_max_input_buffer_size() {
  size_t input_len = 2000;
  setup_filter(0, input_len, input_len);
  float complex *output;
  size_t output_len = 0;
  process(input, input_len, &output, &output_len, filter);
  const float expected[] = {0.0000000f, -0.0000068f, -0.0000428f, -0.0000714f, 0.0002570f, -0.0000263f, -0.0002468f, 0.0002120f, 0.0003470f, 0.0000228f, -0.0017532f, 0.0000311f, -0.0010727f, -0.0014376f, 0.0006578f, 0.0008006f, -0.0007830f, -0.0000535f, -0.0000011f, -0.0005175f, 0.0006146f,
                            -0.0001486f, 0.0001484f, 0.0007192f, -0.0007561f, 0.0001046f, 0.0000750f, 0.0027875f, -0.0004603f, -0.0055335f, -0.0017984f, 0.0152438f, 0.0045422f, -0.0371919f, -0.0067221f, 0.0858634f, -0.0429815f, -0.3576491f, 0.0597844f, -0.1389235f, -0.0190225f, 0.0517429f,
                            0.0094254f, -0.0228723f, -0.0041570f, 0.0100800f, 0.0005283f, -0.0033897f, -0.0000697f, 0.0007920f, -0.0007414f, -0.0001202f, 0.0001707f, -0.0006909f, 0.0006403f, 0.0002212f, -0.0002716f, 0.0005898f, -0.0005393f, -0.0003221f, 0.0003726f, -0.0004887f, 0.0004382f,
                            0.0004230f, -0.0004735f, 0.0003876f, -0.0003371f, -0.0005239f, 0.0005744f, -0.0002865f, 0.0002360f, 0.0006249f, -0.0006754f, 0.0001855f, -0.0001349f, -0.0007258f, 0.0007763f, -0.0000844f, -0.0014146f, -0.0014480f, 0.0042720f, 0.0016814f, -0.0084319f, -0.0050136f,
                            0.0190509f, 0.0136395f, -0.0494887f, -0.0296531f, 0.0160412f, -0.4166364f, 0.0296563f, 0.0494837f, -0.0136332f, -0.0190472f, 0.0050092f, 0.0084378f, -0.0016869f, -0.0042765f, 0.0014524f, 0.0014090f, 0.0000899f, -0.0007717f, 0.0007212f, 0.0001404f, -0.0001909f, 0.0006707f,
                            -0.0006201f, -0.0002413f, 0.0002918f, -0.0005696f, 0.0005190f, 0.0003423f, -0.0003927f, 0.0004685f, -0.0004180f, -0.0004432f, 0.0004937f, -0.0003674f, 0.0003169f, 0.0005441f, -0.0005946f, 0.0002663f, -0.0002158f, -0.0006451f, 0.0006956f, -0.0001652f, 0.0001147f,
                            0.0007460f, 0.0009359f, 0.0017967f, -0.0005725f, -0.0045006f, 0.0013915f, 0.0156302f, -0.0047224f, -0.0370109f, 0.0109193f, 0.0816847f, -0.0579681f, -0.2566931f, 0.0579757f, -0.2566961f, -0.0109169f, 0.0816798f, 0.0047284f, -0.0370047f, -0.0013979f, 0.0156344f,
                            0.0005682f, -0.0045063f, -0.0009304f, 0.0017921f, -0.0001101f, 0.0007515f, -0.0007010f, -0.0001606f, 0.0002111f, -0.0006504f, 0.0005999f, 0.0002615f, -0.0003120f, 0.0005494f, -0.0004988f, -0.0003625f, 0.0004129f, -0.0004483f, 0.0003977f, 0.0004634f, -0.0005139f,
                            0.0003472f, -0.0002966f, -0.0005643f, 0.0006148f, -0.0002461f, 0.0001956f, 0.0006653f, -0.0007157f, 0.0001450f, -0.0000945f, -0.0007662f, -0.0014581f, 0.0014045f, 0.0016916f, -0.0042821f, -0.0050037f, 0.0084419f, 0.0136297f, -0.0190406f, -0.0296641f, 0.0494781f,
                            -0.0160181f, -0.4166428f, 0.0494942f, -0.0296453f, -0.0190575f, 0.0136429f, 0.0084278f, -0.0050191f, -0.0042664f, 0.0016768f, 0.0014191f, -0.0014423f, -0.0007819f, -0.0000798f, 0.0001303f, -0.0007313f, 0.0006808f, 0.0001808f, -0.0002313f, 0.0006302f, -0.0005797f,
                            -0.0002817f, 0.0003322f, -0.0005291f, 0.0004786f, 0.0003827f, -0.0004331f, 0.0004281f, -0.0003775f, -0.0004836f, 0.0005341f, -0.0003270f, 0.0002764f, 0.0005845f, -0.0006350f, 0.0002259f, -0.0001753f, -0.0006855f, 0.0007359f, -0.0001248f, 0.0000742f, 0.0007864f,
                            -0.0005225f, -0.0033852f, 0.0041521f, 0.0100859f, -0.0094302f, -0.0228770f, 0.0190244f, 0.0517377f, -0.0597725f, -0.1389221f, 0.0429922f, -0.3576430f, 0.0067142f, 0.0858579f, -0.0045346f, -0.0371964f, 0.0018020f, 0.0152497f, 0.0004548f, -0.0055290f, -0.0000797f,
                            0.0027819f, 0.0007616f, 0.0001000f, -0.0001505f, 0.0007111f, -0.0006606f, -0.0002010f, 0.0002515f, -0.0006100f, 0.0005595f, 0.0003019f, -0.0003524f, 0.0005089f, -0.0004584f, -0.0004028f, 0.0004533f, -0.0004078f, 0.0003573f, 0.0005038f, -0.0005542f, 0.0003067f,
                            -0.0002562f, -0.0006047f, 0.0006552f, -0.0002057f, 0.0001551f, 0.0007056f, -0.0007561f, 0.0001046f, 0.0000749f, 0.0027875f, -0.0004600f, -0.0055335f, -0.0017990f, 0.0152437f, 0.0045438f, -0.0371917f, -0.0067258f, 0.0858631f, -0.0429660f, -0.3576509f, 0.0597904f,
                            -0.1389209f, -0.0190247f, 0.0517420f, 0.0094263f, -0.0228719f, -0.0041574f, 0.0100798f, 0.0005285f, -0.0033896f, -0.0000698f, 0.0007920f, -0.0007414f, -0.0001203f, 0.0001707f, -0.0006909f, 0.0006403f, 0.0002212f, -0.0002716f, 0.0005898f, -0.0005392f, -0.0003221f,
                            0.0003726f, -0.0004887f, 0.0004382f, 0.0004230f, -0.0004735f, 0.0003876f, -0.0003371f, -0.0005240f, 0.0005744f, -0.0002865f, 0.0002360f, 0.0006249f, -0.0006754f, 0.0001854f, -0.0001349f, -0.0007258f, 0.0007763f, -0.0000843f, -0.0014145f, -0.0014481f, 0.0042720f,
                            0.0016816f, -0.0084317f, -0.0050140f, 0.0190503f, 0.0136403f, -0.0494874f, -0.0296553f, 0.0160593f, -0.4166358f, 0.0296542f, 0.0494849f, -0.0136323f, -0.0190478f, 0.0050088f, 0.0084380f, -0.0016868f, -0.0042766f, 0.0014524f, 0.0014091f, 0.0000900f, -0.0007717f,
                            0.0007212f, 0.0001404f, -0.0001909f, 0.0006707f, -0.0006201f, -0.0002414f, 0.0002918f, -0.0005696f, 0.0005190f, 0.0003423f, -0.0003928f, 0.0004685f, -0.0004179f, -0.0004432f, 0.0004937f, -0.0003674f, 0.0003168f, 0.0005442f, -0.0005946f, 0.0002663f, -0.0002158f,
                            -0.0006451f, 0.0006956f, -0.0001652f, 0.0001147f, 0.0007460f, 0.0009359f, 0.0017967f, -0.0005723f, -0.0045006f, 0.0013908f, 0.0156302f, -0.0047208f, -0.0370111f, 0.0109158f, 0.0816851f, -0.0579570f, -0.2566956f, 0.0579868f, -0.2566936f, -0.0109205f, 0.0816794f};
  assert_complex(expected, sizeof(expected) / (2 * sizeof(float)), output, output_len);
}

void test_parital_input_buffer_size() {
  size_t input_len = 200; // taps is 57
  setup_filter(0, input_len, 2000);
  float complex *output;
  size_t output_len = 0;
  process(input, input_len, &output, &output_len, filter);
  const float expected[] = {0.0000000f, -0.0000068f, -0.0000428f, -0.0000714f, 0.0002570f, -0.0000263f, -0.0002468f, 0.0002120f, 0.0003470f, 0.0000228f, -0.0017532f, 0.0000311f, -0.0010727f, -0.0014376f, 0.0006578f, 0.0008006f, -0.0007830f, -0.0000535f, -0.0000011f, -0.0005175f, 0.0006146f,
                            -0.0001486f, 0.0001484f, 0.0007192f, -0.0007561f, 0.0001046f, 0.0000750f, 0.0027875f, -0.0004603f, -0.0055335f, -0.0017984f, 0.0152438f, 0.0045422f, -0.0371919f, -0.0067221f, 0.0858634f, -0.0429815f, -0.3576491f, 0.0597844f, -0.1389235f};
  assert_complex(expected, 20, output, output_len);
  free(input);
  // another 200 inputs
  setup_input_data(&input, 200, 200);
  process(input, input_len, &output, &output_len, filter);
  const float expectedNextBatch[] = {-0.0190225f, 0.0517429f, 0.0094254f, -0.0228723f, -0.0041570f, 0.0100800f, 0.0005283f, -0.0033897f, -0.0000697f, 0.0007920f, -0.0007414f, -0.0001202f, 0.0001707f, -0.0006909f, 0.0006403f, 0.0002212f, -0.0002716f, 0.0005898f, -0.0005393f, -0.0003221f, 0.0003726f,
                                     -0.0004887f, 0.0004382f, 0.0004230f, -0.0004735f, 0.0003876f, -0.0003371f, -0.0005239f, 0.0005744f, -0.0002865f, 0.0002360f, 0.0006249f, -0.0006754f, 0.0001855f, -0.0001349f, -0.0007258f, 0.0007763f, -0.0000844f, -0.0014146f, -0.0014480f};
  assert_complex(expectedNextBatch, 20, output, output_len);
}

void test_small_input_data() {
  size_t input_len = 198; // taps is 57
  setup_filter(0, input_len, 2000);
  float complex *output;
  size_t output_len = 0;
  process(input, input_len, &output, &output_len, filter);
  free(input);
  // add only 1 complex sample
  // shouldn't be enough for 1 output
  setup_input_data(&input, 200, 2);
  process(input, 2, &output, &output_len, filter);
  const float expectedNextBatch[] = {0};
  assert_complex(expectedNextBatch, 0, output, output_len);
}

void tearDown() {
  destroy_xlating(filter);
  filter = NULL;
  if (input != NULL) {
    free(input);
    input = NULL;
  }
}

void setUp() {
//do nothing
}

int main(void) {
  UNITY_BEGIN();
  RUN_TEST(test_max_input_buffer_size);
  RUN_TEST(test_parital_input_buffer_size);
  RUN_TEST(test_small_input_data);
  return UNITY_END();
}
