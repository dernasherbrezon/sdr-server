#include <stdlib.h>
#include <unity.h>
#include "utils.h"
#include "../src/xlating.h"
#include "../src/lpf.h"

xlating *filter = NULL;
uint8_t *input = NULL;

void setup_filter(size_t input_offset, size_t input_len, size_t max_input) {
  uint32_t sampling_freq = 48000;
  uint32_t target_freq = 9600;
  float *taps = NULL;
  size_t len;
  int code = create_low_pass_filter(1.0f, sampling_freq, target_freq / 2, 2000, &taps, &len);
  TEST_ASSERT_EQUAL_INT(code, 0);
  code = create_frequency_xlating_filter((int) (sampling_freq / target_freq), taps, len, -12000, sampling_freq, max_input, &filter);
  TEST_ASSERT_EQUAL_INT(code, 0);
  setup_input_data(&input, input_offset, input_len);
}

void test_max_input_buffer_size() {
  size_t input_len = 2000;
  setup_filter(0, input_len, input_len);
  float complex *output;
  size_t output_len = 0;
  process(input, input_len, &output, &output_len, filter);
  const float expected[] = {0.0008628f, 0.0008561f, -0.0003212f, -0.0018911f, 0.0005033f, 0.0077399f, -0.0025557f, -0.0186932f, 0.0062834f, 0.0407742f, -0.0307208f, -0.1272911f, 0.0272516f, -0.1294039f, -0.0046343f, 0.0409085f, 0.0021694f, -0.0183142f, -0.0008918f, 0.0078921f, 0.0002496f,
                            -0.0026126f, -0.0000701f, 0.0009386f, -0.0001127f, 0.0007490f, -0.0005693f, 0.0034310f, -0.0011037f, -0.0061779f, -0.0011540f, 0.0146003f, 0.0051857f, -0.0365475f, -0.0073665f, 0.0865069f, -0.0436250f, -0.3582935f, 0.0604286f, -0.1395671f, -0.0183791f, 0.0523874f,
                            0.0087809f, -0.0222288f, -0.0048004f, 0.0094356f, 0.0011727f, -0.0040332f, 0.0005738f, 0.0014364f, -0.0013858f, 0.0005234f, -0.0004727f, -0.0013352f, 0.0012848f, -0.0004225f, 0.0003718f, 0.0012341f, -0.0011836f, 0.0003213f, -0.0002709f, -0.0011331f, 0.0010825f,
                            -0.0002204f, 0.0001699f, 0.0010320f, -0.0009815f, 0.0001195f, -0.0000691f, -0.0009310f, 0.0008804f, -0.0000186f, -0.0000319f, 0.0008299f, -0.0007793f, -0.0000824f, 0.0001328f, -0.0007288f, -0.0007702f, -0.0020914f, 0.0049155f, 0.0023258f, -0.0090763f, -0.0043702f,
                            0.0184074f, 0.0129950f, -0.0488443f, -0.0302966f, 0.0166848f, -0.4159920f, 0.0290119f, 0.0501270f, -0.0142767f, -0.0196916f, 0.0056536f, 0.0077943f, -0.0010436f, -0.0036321f, 0.0008079f, 0.0020525f, -0.0005535f, -0.0014160f, 0.0013655f, -0.0005031f, 0.0004527f,
                            0.0013150f, -0.0012646f, 0.0004022f, -0.0003516f, -0.0012140f, 0.0011635f, -0.0003011f, 0.0002507f, 0.0011129f, -0.0010624f, 0.0002003f, -0.0001498f, -0.0010118f, 0.0009613f, -0.0000993f, 0.0000489f, 0.0009107f, -0.0008601f, -0.0000016f, 0.0000521f, -0.0008096f,
                            0.0007591f, 0.0001026f, 0.0015794f, 0.0024410f, -0.0012169f, -0.0038571f, 0.0007480f, 0.0149857f, -0.0040780f, -0.0376543f, 0.0115627f, 0.0823291f, -0.0586126f, -0.2560497f, 0.0573321f, -0.2573404f, -0.0102726f, 0.0810363f, 0.0053719f, -0.0363602f, -0.0020423f,
                            0.0162779f, -0.0000752f, -0.0051507f, -0.0002860f, 0.0011486f, 0.0005333f, 0.0013959f, -0.0013453f, 0.0004829f, -0.0004324f, -0.0012949f, 0.0012444f, -0.0003819f, 0.0003314f, 0.0011937f, -0.0011432f, 0.0002810f, -0.0002305f, -0.0010926f, 0.0010422f, -0.0001800f,
                            0.0001295f, 0.0009917f, -0.0009411f, 0.0000792f, -0.0000287f, -0.0008905f, 0.0008400f, 0.0000219f, -0.0000723f, 0.0007894f, -0.0007389f, -0.0001228f, -0.0021016f, 0.0007600f, 0.0023360f, -0.0049256f, -0.0043603f, 0.0090863f, 0.0129853f, -0.0183971f, -0.0303075f,
                            0.0488337f, -0.0153737f, -0.4172862f, 0.0501376f, -0.0290010f, -0.0197019f, 0.0142863f, 0.0077844f, -0.0056635f, -0.0036220f, 0.0010333f, 0.0020625f, -0.0007978f, -0.0014263f, 0.0005636f, -0.0005131f, -0.0013757f, 0.0013251f, -0.0004627f, 0.0004123f, 0.0012746f,
                            -0.0012241f, 0.0003617f, -0.0003113f, -0.0011735f, 0.0011230f, -0.0002607f, 0.0002103f, 0.0010724f, -0.0010220f, 0.0001598f, -0.0001094f, -0.0009714f, 0.0009208f, -0.0000589f, 0.0000085f, 0.0008703f, -0.0008198f, -0.0000420f, 0.0000925f, -0.0007692f, 0.0007187f,
                            0.0001429f, 0.0001209f, -0.0027408f, 0.0035077f, 0.0107293f, -0.0100737f, -0.0235214f, 0.0196689f, 0.0510942f, -0.0591290f, -0.1382776f, 0.0423478f, -0.3569994f, 0.0060706f, 0.0852136f, -0.0038902f, -0.0378400f, 0.0024454f, 0.0158941f, -0.0001896f, -0.0048856f,
                            -0.0007232f, 0.0021374f, 0.0014061f, -0.0005434f, 0.0004929f, 0.0013555f, -0.0013050f, 0.0004424f, -0.0003920f, -0.0012545f, 0.0012038f, -0.0003415f, 0.0002910f, 0.0011533f, -0.0011027f, 0.0002406f, -0.0001901f, -0.0010522f, 0.0010017f, -0.0001396f, 0.0000892f,
                            0.0009511f, -0.0009006f, 0.0000387f, 0.0000118f, -0.0008500f, 0.0007995f, 0.0000622f, -0.0001127f, 0.0007490f, -0.0005695f, 0.0034309f, -0.0011035f, -0.0061779f, -0.0011546f, 0.0146003f, 0.0051873f, -0.0365473f, -0.0073702f, 0.0865066f, -0.0436095f, -0.3582954f,
                            0.0604347f, -0.1395645f, -0.0183813f, 0.0523866f, 0.0087819f, -0.0222284f, -0.0048008f, 0.0094353f, 0.0011729f, -0.0040331f, 0.0005737f, 0.0014365f, -0.0013858f, 0.0005233f, -0.0004726f, -0.0013352f, 0.0012848f, -0.0004224f, 0.0003718f, 0.0012341f, -0.0011837f,
                            0.0003213f, -0.0002708f, -0.0011332f, 0.0010825f, -0.0002204f, 0.0001699f, 0.0010320f, -0.0009815f, 0.0001194f, -0.0000691f, -0.0009310f, 0.0008804f, -0.0000186f, -0.0000320f, 0.0008299f, -0.0007793f, -0.0000824f, 0.0001329f, -0.0007288f, -0.0007701f, -0.0020915f,
                            0.0049154f, 0.0023260f, -0.0090761f, -0.0043706f, 0.0184069f, 0.0129958f, -0.0488430f, -0.0302987f, 0.0167028f, -0.4159912f, 0.0290097f, 0.0501283f, -0.0142758f, -0.0196922f, 0.0056533f, 0.0077946f, -0.0010434f, -0.0036322f, 0.0008079f, 0.0020525f, -0.0005534f,
                            -0.0014161f, 0.0013655f, -0.0005031f, 0.0004526f, 0.0013150f, -0.0012646f, 0.0004021f, -0.0003515f, -0.0012140f, 0.0011635f, -0.0003010f, 0.0002507f, 0.0011129f, -0.0010624f, 0.0002002f, -0.0001497f, -0.0010118f, 0.0009613f, -0.0000993f, 0.0000488f, 0.0009107f,
                            -0.0008601f, -0.0000016f, 0.0000521f, -0.0008096f, 0.0007591f, 0.0001026f, 0.0015793f, 0.0024411f, -0.0012167f, -0.0038572f, 0.0007474f, 0.0149858f, -0.0040764f, -0.0376545f, 0.0115592f, 0.0823296f, -0.0586015f, -0.2560522f, 0.0573432f, -0.2573379f, -0.0102761f,
                            0.0810358f};
  assert_complex(expected, sizeof(expected) / (2 * sizeof(float)), output, output_len);
}

void test_parital_input_buffer_size() {
  size_t input_len = 200; // taps is 57
  setup_filter(0, input_len, 2000);
  float complex *output;
  size_t output_len = 0;
  process(input, input_len, &output, &output_len, filter);
  const float expected[] = {0.0008628f, 0.0008561f, -0.0003212f, -0.0018911f, 0.0005033f, 0.0077399f, -0.0025557f, -0.0186932f, 0.0062834f, 0.0407742f, -0.0307208f, -0.1272911f, 0.0272516f, -0.1294039f, -0.0046343f, 0.0409085f, 0.0021694f, -0.0183142f, -0.0008918f, 0.0078921f, 0.0002496f,
                            -0.0026126f, -0.0000701f, 0.0009386f, -0.0001127f, 0.0007490f, -0.0005693f, 0.0034310f, -0.0011037f, -0.0061779f, -0.0011540f, 0.0146003f, 0.0051857f, -0.0365475f, -0.0073665f, 0.0865069f, -0.0436250f, -0.3582935f, 0.0604286f, -0.1395671f};
  assert_complex(expected, 20, output, output_len);
  free(input);
  // another 200 inputs
  setup_input_data(&input, 200, 200);
  process(input, input_len, &output, &output_len, filter);
  const float expectedNextBatch[] = {-0.0183791f, 0.0523874f, 0.0087809f, -0.0222288f, -0.0048004f, 0.0094356f, 0.0011727f, -0.0040332f, 0.0005738f, 0.0014364f, -0.0013858f, 0.0005234f, -0.0004727f, -0.0013352f, 0.0012848f, -0.0004225f, 0.0003718f, 0.0012341f, -0.0011836f, 0.0003213f, -0.0002709f,
                                     -0.0011331f, 0.0010825f, -0.0002204f, 0.0001699f, 0.0010320f, -0.0009815f, 0.0001195f, -0.0000691f, -0.0009310f, 0.0008804f, -0.0000186f, -0.0000319f, 0.0008299f, -0.0007793f, -0.0000824f, 0.0001328f, -0.0007288f, -0.0007702f, -0.0020914f};
  assert_complex(expectedNextBatch, 20, output, output_len);
}

void test_small_input_data() {
  size_t input_len = 198; // taps is 57
  setup_filter(0, input_len, 2000);
  float complex *output;
  size_t output_len = 0;
  process(input, input_len, &output, &output_len, filter);
  free(input);
  // add only 1 complex sample
  // shouldn't be enough for 1 output
  setup_input_data(&input, 200, 2);
  process(input, 2, &output, &output_len, filter);
  const float expectedNextBatch[] = {0};
  assert_complex(expectedNextBatch, 0, output, output_len);
}

void tearDown() {
  destroy_xlating(filter);
  filter = NULL;
  if (input != NULL) {
    free(input);
    input = NULL;
  }
}

void setUp() {
//do nothing
}

int main(void) {
  UNITY_BEGIN();
  RUN_TEST(test_max_input_buffer_size);
  RUN_TEST(test_parital_input_buffer_size);
  RUN_TEST(test_small_input_data);
  return UNITY_END();
}
